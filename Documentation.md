# Описание проекта External Image Server Php Sample

[[_TOC_]]

## Генерация проекта

Основа для проекта была сгенерирована по файлу [OpenApi спецификации](https://tfs/tfs/CC_Collection/CustomersCanvas/_git/gist_ExternalStorage_BackendApp?path=%2Fsrc%2FAurigma.ExternalStorageApi.ApiClient%2FExternalStorageApi.OpenApi3.swagger.json) с использованием open-source генератора [open-api-generator](https://github.com/OpenAPITools/openapi-generator). Для генерации был выбран фреймворк Laravel.

Команда для генерации проекта:

```
openapi-generator-cli generate -i <ваш путь до файла> -g php-laravel -o .<название папки, куда вы хотите положить проект>
```

В файле "routes/api.php" после генерации во всех путях была лишняя секция "/api", в ссылках происходило дублирование этой части, из-за чего "/api" было убрано во всех путях.

Как было: http://localhost:8000/api/api/...

Как стало: http://localhost:8000/api/...


## Как работать с API

Спецификация включает в себя описание 6 эндпоинтов. Ниже представлено описание каждого, содержащее следующее:

* назначение
* защищенность
* путь
* описание тела запроса/query-параметров
* формат и модель возвращаемого ответа
* возможные коды ответов

### Контроллер *Info*

#### Метод infoGetInfo()

Получение текущей версии сервера, а так же информации о реализованных функциях API

- URL: 'GET /api/image-storage/v1/info'
- Авторизация: нет
- Тело: нет
- Query-параметры: нет
- Ответы:
    - 200 - успешная операция
    ```
    {
        "name": "Image source",
        "version": "0.0.1",
        "features": [
            "AllowCreate",
            "AllowDelete",
            "AllowSearch"
        ]
    }
    ```

Параметр "features" передает информацию о реализованных функциях сервиса.

### Контроллер *Images*

#### Метод imagesCreate()

Добавление файла пользователя в хранилище файлов и создание записи в базе данных о файле пользователя, также создание превью файла и его сохранение в хранилище.

- URL: 'POST /api/image-storage/v1/images'
- Авторизация: Brearer token (JWT)
- Тело (multipart/form-data)
```
file = бинанрный файл
solveConflictStrategy = Overwrite | Rename | Abort | Skip
```
- Query-параметры: нет
- Ответы:
    - 201 - успешное создание
    ```
    {
        "id": "Guid",
        "title": "File Name",
        "thumbnailUrl": "http://localhost:8000/api/previews/someGuidPreview"
    }
    ```
    - 400 - проблемы с параметрами запроса
    ```
    {
        "message": "No file uploaded" | "message": "No strategy provided"
    }
    ```
    - 401 - проблемы с авторизацией
    ```
    {
        "message": "Unauthenticated."
    }
    ```
    - 409 - обнаружен конфликт, стратегия не описана или Abort
    ```
    {
        "message": "No strategy provided" | "message": "File already exists"
    }
    ```

#### Метод imagesGetAll()

Получение всех записей файлов пользователя с учетом фильтрации по вхождению строки в имя файла и пагинации

- URL: 'GET /api/image-storage/v1/images'
- Авторизация: Brearer token (JWT)
- Тело: нет
- Query-параметры:
```
search: <текст>
take: <число>
skip: <число>
```
- Ответы:
    - 200 - успешная операция
    ```
    [
        {
            "id": "Guid1",
            "title": "File Name 1",
            "thumbnailUrl": "http://localhost:8000/api/previews/someGuidPreview1"
        }
        {
            "id": "Guid2",
            "title": "File Name 2",
            "thumbnailUrl": "http://localhost:8000/api/previews/someGuidPreview2"
        }
    ]
    ```
    - 400 - проблемы с параметрами запроса
    ```
    {
        "message": "Incorrect data"
    }
    ```
    - 401 - проблемы с авторизацией
    ```
    {
        "message": "Unauthenticated."
    }
    ```

#### Метод imagesDelete(someId)

Удаление файла пользователя и его превью из хранилища, также удаление записи о файле из базы данных

- URL: 'DELETE /api/image-storage/v1/images/{someId}'
- Авторизация: Brearer token (JWT)
- Тело: нет
- Query-параметры: нет
- Ответы:
    - 200 - успешная операция, файл удален
    - 400 - проблемы с параметрами запроса, неправильный id
    ```
    {
        "message": "Invalid ID format"
    }
    ```
    - 401 - проблемы с авторизацией
    ```
    {
        "message": "Unauthenticated."
    }
    ```
    - 404 - проблема с поиском ресурса, отсутствие информации о файле в базе данных
    ```
    {
        "message": "FileInfo is not found."
    }
    ```

#### Метод imagesGet(someId)

Получение информации о файле пользователя из базы данных и ссылки на превью файла

- URL: 'GET /api/image-storage/v1/images/{someId}'
- Авторизация: Brearer token (JWT)
- Тело: нет
- Query-параметры: нет
- Ответы:
    - 200 - успешная операция, файл найден
    ```
    {
        "id": "Guid",
        "title": "File Name",
        "thumbnailUrl": "http://localhost:8000/api/previews/someGuidPreview"
    }
    ```
    - 400 - проблемы с параметрами запроса, неправильный id
    ```
    {
        "message": "Invalid ID format"
    }
    ```
    - 401 - проблемы с авторизацией
    ```
    {
        "message": "Unauthenticated."
    }
    ```
    - 404 - проблема с поиском ресурса, отсутствие информации о файле в базе данных
    ```
    {
        "message": "FileInfo is not found."
    }
    ```

#### Метод imagesGetContent(someId)

Получение файла пользователя по id

- URL: 'GET /api/image-storage/v1/images/{someId}/content'
- Авторизация: Brearer token (JWT)
- Тело: нет
- Query-параметры: нет
- Ответы:
    - 200 - успешная операция, файл найден, в ответе файловый поток
    - 400 - проблемы с параметрами запроса, неправильный id
    ```
    {
        "message": "Invalid ID format"
    }
    ```
    - 401 - проблемы с авторизацией
    ```
    {
        "message": "Unauthenticated."
    }
    ```
    - 404 - проблема с поиском ресурса, отсутствие информации о файле в базе данных
    ```
    {
        "message": "FileInfo is not found."
    }
    ```

#### Общие принципы:

* В параметрах Headers всех этих эндпоинтов должны быть следующие значения:

    * Accept = aplication/json
    * Authorization = Bearer <someToken>

* POST-запрос сохраняет файл в системе, где создается модель, описывающая файл - ID, имя файла и ссылка на превью, и, как и в GET-запросе, возвращается назад.
* Если в POST-запросе пользователь будет пытаться загружать файл с именем, которое уже есть у другого файла сохраненного в системе, то произойдет конфликт, который решается с использованием стратегий. Подробнее о стратегиях в теле POST-запроса описано в пункте [Стратегии при конфликте имен загружаемых файлов](#стратегии-при-конфликте-имен-загружаемых-файлов)
* Для получения (или удаления) файла необходимо указать ID этого файла из базы данных в пути запроса.
* ID файла имеет формат GUID.
* В title отображается название файла вместе с его расширением.
* В thumbnail отображается ссылка на превью файла клиента, создается превью в момент, когда клиент отправляет файл в POST-запросе, после чего собирается ссылка на превью. Размеры превью можно задать в файле .env в параметрах PREVIEW_WIDTH, PREVIEW_HEIGHT.
* GET-запрос на получение контента возвращает файловый поток.

Помимо эндпоинтов описанных в спецификации в проект были добавлены ещё 4 дополнительных:

### Контроллер *Previews*

#### Метод previewsGet(someId)

Получение превью картинки

- URL: 'GET /api/previews/{someId}'
- Авторизация: нет
- Тело: нет
- Query-параметры: нет
- Ответы:
    - 200 - успешная операция, превью файла найдено, в ответе файловый поток превью
    - 400 - проблемы с параметрами запроса, неправильный id
    ```
    {
        "message": "Invalid ID format"
    }
    ```
    - 404 - проблема с поиском ресурса, отсутствие информации о файле в базе данных
    ```
    {
        "message": "FileInfo is not found."
    }
    ```

### Контроллер *JWTAuth*

#### Метод register()

Регистрация пользователя

- URL: 'POST /api/auth/register'
- Авторизация: нет
- Тело (multipart/form-data)
```
name = <your_value>
email = <your_value> (должно быть уникально)
password = <your_value>
```
- Query-параметры: нет
- Ответы:
    - 200 - успешная операция, пользователь зарегистрирован
    ```
    {
        "message": "Successful registration!"
    }
    ```

#### Метод login()

Авторизация пользователя

- URL: 'POST /api/auth/login'
- Авторизация: нет
- Тело (multipart/form-data)
```
email = <your_value>
password = <your_value>
```
- Query-параметры: нет
- Ответы:
    - 200 - успешная операция, пользователь авторизовался
    ```
    {
        "access_token": "<Token>",
        "token_type": "bearer",
        "expires_in": <Время, когда токен истечет, в формате Unix timestamp>
    }
    ```
    - 401 - не успешная авторизация
    ```
    {
        "error": "Unauthorized"
    }
    ```

#### Метод logout()

Прекращение сеанса работы авторизованного пользователя

- URL: 'POST /api/auth/logout'
- Авторизация: Brearer token (JWT)
- Тело: нет
- Query-параметры: нет
- Ответы:
    - 200 - успешная операция, пользователь закончил сессию
    ```
    {
        "message": "Successfully logged out"
    }
    ```
    - 401 - проблема авторизации
    ```
    {
        "error": "Unauthorized"
    }
    ```

#### Принципы авторизации/регистрации:

* После прекращения сеанса работы авторизованного пользователя токен становится недействительным. Чтобы прекратить сеанс, вызовите эндпоинт logout и передайте в заголовок Authorization токен сессии, которую нужно прекратить.
* После истечения времени жизни токена (60 минут), он становится недействительным, время жизни токена можно поменять в файле ".env" в параметре "JWT_TTL".
* При регистрации нужно заполнять поля "name", "email" (уникальными значениями), "password".
* Чтобы зайти за пользователя, достаточно ввести ранее введенные значения параметров "email" и "password". После автоизации пользователь получает токен, в котором хранится информация о пользователе, его id.


## Использование JWT

Для работы с токенами используется пакет:
```
tymon/jwt-auth: ^1.0.
```

При регистрации данные пользователя записываются в таблицу "users", в качестве уникального значения используется "email" пользователя.
После авторизации пользователь получает токен, который используется при обращении к защищенным эндпоинтам. Из токена извлекается "id" пользователя в сервисе *AuthService*, который передаётся в основной сервис *ImageService*. Там "id" используется для:

* Названия папки пользователя
* Записи в базу данных информации о файлах
* Поиска информации о файлах по "id" пользователя
* Отдельного хранения данных пользователей

## Логика работы с файлами

* Загрузка файла:
    * Имя файла и расширение сохраняются в БД, а так же используются при сохранении во внутренней папке пользователя на сервере
    * Далее идет проверка на наличие информации о данном файле пользователя в базе данных
        * Если запись нашлась, то, в зависимости от того, какая стратегия указана, осуществляется решение конфликта. Подробнее о решении конфликтов можно прочесть ниже в подразделе [Стратегии при конфликте имен загружаемых файлов](#стратегии-при-конфликте-имен-загружаемых-файлов)
        * Если запись не нашлась, то файл сохраняется в папке пользователя, сохраняется информация об этом файле, создается и сохраняется превью файла
    * В качестве ответа составляется модель *ImageInfoModel* следующего вида:
        ```
        {
            "id": "Guid",
            "title": "File Name",
            "thumbnailUrl": "http://localhost:8000/api/previews/someGuidPreview"
        }
        ```

* Получение списка с информацией о файлах с учетом фильтрации и пагинации:
    * В качестве параметров запроса принимаются: search (ищет совпадающие полные названия файлов), take (ограничивает количество записей, по умолчанию 10), skip (пропускает указанное количество записей)
    * Далее строится запрос в базу данных, с учетом "id" пользователя
    Список результата проходит через составление модели *ImageInfoModel* и возвращается пользователю

* Удаление файла и записи о нем:
    * По "id" файла и пользователя ищется название файла
    * Строится путь до файла и до превью файла
    * Удаляются файл и его превью
    * Удаляется запись о файле

* Получение информации об одном файле:
    * По "id" файла и пользователя ищется название файла
    * Строится путь до файла
    * Составляется модель *ImageInfoModel* для ответа пользователю

* Получение файла (отображение картинки):
    * По "id" файла и пользователя ищется название файла
    * Строится путь до файла
    * Возвращается файл

Описание ошибок

* *FileNotFoundException* - отсутствие записи о файле в базе данных
* *Exception* - отсутствие файла в хранилище, ошибка удаления файла, ошибка работы сервера
* *ConflictException* - в случае конфликта имен файлов
* *InvalidArgumentException* - в случае некорректного запроса, отсутствие файла и стратегии при загрузке, в случае некорректных данных в параметрах "take" и "skip" (вносить нужно числовые значения, они передаются строкой, но потом идет проверка на возможность изменения типа данных)

## Логика работы с превью

Для создания превью используется API системы Customer's Canvas, подробнее как работать с системой Customer's Canvas описано [тут](#авторизация-в-customers-canvas).

Для работы с системой Customer's Canvas и создания превью были использованы следующие пакеты:
```
aurigma/php-design-atoms-client: ^2.1
aurigma/php-storefront-client: 2.0.1
```

* При загрузке файла (эндпоинт сохранения файла в систему):

    * Для доступа к сервису *DesignAtomsApi* создается объект класса *DesignAtomsImagesApi*, для использования функции, преобразующей файл в превью
    * Файл из типа *UploadedFile* меняется на тип *SplFileObject*
    * Создается превью-файл с использованием функции класса *DesignAtomsImagesApi* и в качестве одного из агрументов отправляется файл типа *SplFileObject*, преобразованный ранее
    * Превью сохраняется в папке пользователя "storage/app/someUserId/preview"
    
* При удалении файла:

    * По названию файла проивходит поиск превью
    * Удаляется превью

* Получение превью файла по эндпоинту со свободным доступом:
    
    * Переход по ссылке "http://localhost:8000/api/previews/{someGuidPreview}"
    * По "id" файла ищется название файла
    * Строится путь до файла (для проверки наличия файла)
    * Строится путь до первью
    * Возвращается превью


## Стратегии при конфликте имен загружаемых файлов

В API реализованы стратегии загрузки файлов, предотвращающие конфликты имён файлов:

* Overwrite – перезаписывает файл, если такой уже существует. Старый файл удаляется, создаётся новый с тем же именем, обновляется превью и timestamp записи в БД.

* Rename – загружает файл под новым именем, если файл с таким именем уже существует. Создаётся новая запись в БД и генерируется новое превью.

* Abort – останавливает загрузку, если файл с таким именем уже есть. Возвращает ошибку.

* Skip – не загружает файл, если такой уже есть. Возвращает информацию о существующем файле.

Если стратегия не указана, загрузка будет прервана в случае конфликта имен.


## Авторизация в Customers Canvas

В системе Customers Canvas для организации процесса авторизации используется Identity Server 4, который обеспецивает возможность авторизации по clientId и clientSecret в соответствии со стандартом OAuth2 и Client credentials flow.

Для работы с Customers Canvas необходимо получить доступ через CC_HUB_API_URL.

В файле .env должны быть указаны параметры:

```
CC_HUB_API_URL=<YOUR_API_URL>
CC_HUB_CLIENT_ID=<YOUR_CLIENT_ID>
CC_HUB_CLIENT_SECRET=<YOUR_CLIENT_SECRET>
```

Подробнее как получить эти параметры написано в [статье](https://customerscanvas.com/dev/backoffice/auth.html)
